
// This is an autogenerated file from Firebase Studio.

'use server';

/**
 * @fileOverview Compares product names, quantities, discounts, and taxes between a sales order document and one or more purchase order documents (PDF, image, CSV, or Excel) using AI.
 * If multiple Purchase Orders are provided, the AI is currently instructed to focus on the first one for detailed comparison against the Sales Order.
 * Identifies both discrepancies and matching items for overall fields, and provides a detailed comparison for product line items.
 *
 * - compareOrderDetails - Compares order details from document content and identifies discrepancies, matches, and detailed product line comparisons.
 * - CompareOrderDetailsInput - The input type for the compareOrderDetails function, expecting documents as data URIs.
 * - CompareOrderDetailsOutput - The output type for the compareOrderDetails function.
 * - MatchedItem - Type for general matched fields.
 * - Discrepancy - Type for general discrepancies.
 * - ProductLineItemComparison - Type for detailed product line item comparisons.
 */

import {ai} from '@/ai/genkit';
import {z} from 'genkit';

const CompareOrderDetailsInputSchema = z.object({
  salesOrderPdfDataUri: z.string().describe("The sales order document (PDF, image, CSV, or Excel) as a data URI. Expected format: 'data:<mimetype>;base64,<encoded_data>'."),
  purchaseOrderPdfDataUris: z.array(z.string()).describe("An array of purchase order documents (PDF, image, CSV, or Excel) as data URIs. Expected format: 'data:<mimetype>;base64,<encoded_data>'. Can be an empty array if no POs are linked or found."),
});
export type CompareOrderDetailsInput = z.infer<typeof CompareOrderDetailsInputSchema>;

// New internal schema for the prompt after data pre-processing
const InternalPromptInputSchema = z.object({
  salesOrderPdfDataUri: z.string(),
  firstPurchaseOrderPdfDataUri: z.string().optional(),
  hasPurchaseOrders: z.boolean(),
  totalPurchaseOrderCount: z.number(),
  additionalPurchaseOrderUris: z.array(z.string()),
});
type InternalPromptInput = z.infer<typeof InternalPromptInputSchema>;


const DiscrepancySchema = z.object({
  field: z.string().describe('The general document field with a discrepancy (e.g., PO Number, Overall Discount, Payment Terms, Buyer Name, Shipping Address, or an unmatched product). This is for non-product line items or for flagging products found in one order but not the other.'),
  purchaseOrderValue: z.string().describe('The value from the purchase order document (or the first PO if multiple were provided). For an unmatched SO product, this might be "Desc: [SO Product Description], Qty: [SO Quantity], Unit Price: [SO Unit Price]" or similar if only found in SO, or simply "N/A" or "No PO Provided".'),
  salesOrderValue: z.string().describe('The value from the sales order document. For an unmatched PO product, this might be "Desc: [PO Product Description], Qty: [PO Quantity], Unit Price: [PO Unit Price]" or similar if only found in PO, or simply "N/A".'),
  reason: z.string().describe('The reason for the discrepancy, or why it might be a mismatch (e.g., "Quantities differ", "Product found only in PO", "Buyer names differ").'),
});
export type Discrepancy = z.infer<typeof DiscrepancySchema>;


const MatchedItemSchema = z.object({
  field: z.string().describe('The general document field that matches (e.g., PO Number, Vendor Name, Order Date). This is for non-product line items.'),
  value: z.string().describe('The common value found in both the sales order and the (first) purchase order document.'),
  matchQuality: z.enum(['exact', 'normalized', 'inferred']).optional().describe('The quality of the match (e.g., exact string match, match after normalization, or inferred match based on context). Default to "exact" if not specified.'),
});
export type MatchedItem = z.infer<typeof MatchedItemSchema>;

const ProductLineItemComparisonSchema = z.object({
  poProductDescription: z.string().optional().describe('Product name, description, or SKU from the Purchase Order line item (first PO if multiple provided). Use "N/A" if the item is SO_ONLY, no PO was provided, or if this specific detail is not present/extractable from the PO line item.'),
  poQuantity: z.string().optional().describe('Quantity from the Purchase Order line item. Use "N/A" if the item is SO_ONLY, no PO provided, or if this specific detail is not present/extractable.'),
  poUnitPrice: z.string().optional().describe('Unit price from the Purchase Order line item. Use "N/A" if the item is SO_ONLY, no PO provided, or if this specific detail is not present/extractable.'),
  poTotalPrice: z.string().optional().describe('Total price for the line item from the Purchase Order. Use "N/A" if the item is SO_ONLY, no PO provided, or if this specific detail is not present/extractable.'),
  soProductDescription: z.string().optional().describe('Product name, description, or SKU from the Sales Order line item. Use "N/A" if the item is PO_ONLY or if this specific detail is not present/extractable from the SO line item.'),
  soQuantity: z.string().optional().describe('Quantity from the Sales Order line item. Use "N/A" if the item is PO_ONLY or if this specific detail is not present/extractable.'),
  soUnitPrice: z.string().optional().describe('Unit price from the Sales Order line item. Use "N/A" if the item is PO_ONLY or if this specific detail is not present/extractable.'),
  soTotalPrice: z.string().optional().describe('Total price for the line item from the Sales Order. Use "N/A" if the item is PO_ONLY or if this specific detail is not present/extractable.'),
  status: z.enum(['MATCHED', 'MISMATCH_QUANTITY', 'MISMATCH_UNIT_PRICE', 'MISMATCH_TOTAL_PRICE', 'MISMATCH_DESCRIPTION', 'PO_ONLY', 'SO_ONLY', 'PARTIAL_MATCH_DETAILS_DIFFER']).describe('The comparison status for this product line item pairing.'),
  comparisonNotes: z.string().describe('AI\'s brief notes explaining the status or highlighting specific differences for this line item (e.g., "Quantities differ", "Unit prices mismatch", "Product found only in PO", "No PO document provided for comparison").'),
});
export type ProductLineItemComparison = z.infer<typeof ProductLineItemComparisonSchema>;

// Strict schema for the flow's final output and the exported type
const StrictCompareOrderDetailsOutputSchema = z.object({
  discrepancies: z.array(DiscrepancySchema).describe('An array of general discrepancies found (e.g., for header fields, overall totals, terms, or unmatched products). This should always be an array, even if empty.'),
  matchedItems: z.array(MatchedItemSchema).describe('An array of general items/fields that match (e.g., for header fields). This should always be an array, even if empty. Strive to find matches for common header fields.'),
  productLineItemComparisons: z.array(ProductLineItemComparisonSchema).describe('An array detailing the comparison of each product line item found in the documents. This should always be an array, even if empty.'),
  summary: z.string().describe('A summary of the overall comparison, highlighting key discrepancies, confirmed matches, and product line item findings. If any limitations were encountered processing the entirety of any document, or if no PO was provided, this must be noted here.'),
});
export type CompareOrderDetailsOutput = z.infer<typeof StrictCompareOrderDetailsOutputSchema>;

// Permissive schema for the AI's direct output, allowing optional top-level array fields
const AiPermissiveOutputSchema = z.object({
  discrepancies: z.array(DiscrepancySchema).optional().describe('An array of general discrepancies found (e.g., for header fields, overall totals, terms, or unmatched products).'),
  matchedItems: z.array(MatchedItemSchema).optional().describe('An array of general items/fields that match (e.g., for header fields). Strive to find matches for common header fields.'),
  productLineItemComparisons: z.array(ProductLineItemComparisonSchema).optional().describe('An array detailing the comparison of each product line item found in the documents.'),
  summary: z.string().optional().describe('A summary of the overall comparison, highlighting key discrepancies, confirmed matches, and product line item findings. If any limitations were encountered processing the entirety of any document, or if no PO was provided, this must be noted here.'),
});


export async function compareOrderDetails(input: CompareOrderDetailsInput): Promise<CompareOrderDetailsOutput> {
  return compareOrderDetailsFlow(input);
}

const compareOrderDetailsPrompt = ai.definePrompt({
  name: 'compareOrderDetailsPrompt',
  input: {
    schema: InternalPromptInputSchema, // Use the new internal schema
  },
  output: {
    schema: AiPermissiveOutputSchema, // Use permissive schema for AI output
  },
  prompt: `You are an AI assistant specializing in comparing sales orders (SOs) with associated purchase orders (POs) provided as various document types.
Your task is to meticulously analyze the **entire content** of all provided documents, from start to finish, including all pages, headers, footers, and line items.
It is absolutely critical for the accuracy of this task that every piece of information, from all pages and all sections of all documents, is meticulously reviewed and considered. Incomplete analysis or overlooking any part of the documents will lead to incorrect and unusable results. Do not stop processing part-way through a document.

The documents can be in PDF, image (e.g., JPEG, PNG), CSV, or Excel (XLS, XLSX) format.
- If the document is an image, perform OCR to extract textual content.
- If the document is a CSV or Excel file, parse the tabular data to identify order details. Look for headers like 'Product', 'Item', 'Quantity', 'Price', 'Amount', 'Discount', 'Tax', 'PO Number', 'Buyer', 'Vendor', 'Payment Terms', etc.
- If the document is a PDF, extract its textual content thoroughly from all pages.

Analyze the content of the following Sales Order document and any provided Purchase Order documents:
Ensure you process all pages and sections of each document.

Sales Order Document:
{{media url=salesOrderPdfDataUri}}

Purchase Order Document(s):
{{#if hasPurchaseOrders}}
  {{#if firstPurchaseOrderPdfDataUri}} {{! Ensure first PO URI exists before trying to use it }}
    {{#if (eq totalPurchaseOrderCount 1)}}
      A single Purchase Order document is provided:
      {{media url=firstPurchaseOrderPdfDataUri}}
      You will compare this Purchase Order against the Sales Order.
    {{else}}
      Multiple ({{totalPurchaseOrderCount}}) Purchase Order documents are provided. For this comparison, **focus primarily on the FIRST Purchase Order document listed below** when comparing line items and specific PO values against the Sales Order. You may reference other POs for context if it helps clarify discrepancies or matches related to the first PO, but the detailed values (quantities, prices) reported for 'purchaseOrderValue' or 'poProductDescription' etc., should come from the first PO.
      First Purchase Order Document:
      {{media url=firstPurchaseOrderPdfDataUri}}

      {{#if additionalPurchaseOrderUris.length}}
        Additional Purchase Order Documents ({{additionalPurchaseOrderUris.length}} for context, less detailed focus):
        {{#each additionalPurchaseOrderUris}}
          Additional PO (Context): {{media url=this}}
        {{/each}}
      {{/if}}
    {{/if}}
  {{/if}}
{{else}}
  No Purchase Order document was provided for comparison. Proceed with analyzing the Sales Order. For any fields or items that would normally come from a Purchase Order, indicate "N/A - No PO Provided" or similar. All Sales Order line items should be treated as 'SO_ONLY'. Note the absence of a PO in your summary.
{{/if}}

Based on your analysis of the document contents, provide the following in a valid JSON format:

**1. General Document Field Comparison (for 'discrepancies' and 'matchedItems' arrays):**
   (Instructions for this section remain largely the same, but remember to specify "first PO" or "No PO Provided" where applicable)

   **A. Document-Level Field Discrepancies:**
      - Meticulously compare **general document fields that are NOT product line items** between the Sales Order and the **first Purchase Order (if provided)**. These include, but are not limited to: PO Number, Order Date, Buyer/Seller names and addresses, Shipping/Billing addresses, Payment Terms, Shipping Terms, Incoterms, overall document Subtotals, overall Taxes, overall Discounts, and Grand Totals.
      - **Pay extremely close attention to Buyer/Customer names and their full addresses (Shipping and Billing). Even minor differences in names (e.g., 'Titan Steel Works' vs. 'Steel America') or any significant differences in address components (street, city, state, zip code) MUST be flagged as discrepancies.** Do not assume entities are the same if their names or addresses show such variations.
      - For any discrepancies found in these **document-level fields**, populate the 'discrepancies' array with objects specifying: 'field' (e.g., "Payment Terms", "Grand Total", "Buyer Address", "Buyer Name"), 'purchaseOrderValue' (from first PO, or "No PO Provided"), 'salesOrderValue', and 'reason' for the discrepancy (e.g., "Buyer names differ", "Shipping addresses do not match").

   **B. Unmatched Product Line Item Discrepancies:**
      - During your detailed product line item analysis (detailed in section 2 below), you will identify some products as 'PO_ONLY' or 'SO_ONLY'.
      - For these **unmatched products**, you must also add an entry to this 'discrepancies' array.
      - For items found in the **first PO (if provided)** but not in the SO: 
        'field': "Unmatched PO Product: [Product Name/SKU from PO line item]", 
        'purchaseOrderValue': "Desc: [Product Name/SKU from PO line item], Qty: [Quantity from PO line item], Unit Price: [Unit Price from PO line item]", 
        'salesOrderValue': "Not found in SO", 
        'reason': "Product listed in Purchase Order only."
      - For items found in the SO but not in the **first PO (or if no PO provided)**: 
        'field': "Unmatched SO Product: [Product Name/SKU from SO line item]", 
        'purchaseOrderValue': "Not found in PO" (or "No PO Provided"), 
        'salesOrderValue': "Desc: [Product Name/SKU from SO line item], Qty: [Quantity from SO line item], Unit Price: [Unit Price from SO line item]", 
        'reason': "Product listed in Sales Order only (or no PO to compare against)."
      - **Crucially, ensure that every product identified with a status of 'PO_ONLY' or 'SO_ONLY' during the detailed product line item analysis (section 2) results in a corresponding entry in this 'discrepancies' array (section 1).**

   **C. Matched General Document Fields:**
      - Identify general matching items/fields (non-product line items) between the SO and the **first PO (if provided)**. For each, populate the 'matchedItems' array with objects specifying: 'field', 'value', 'matchQuality'. Strive to find matches for common header fields such as PO Number, Vendor Name, Order Dates, etc.
      - **For critical fields like Buyer names and full addresses, only list them as 'matchedItems' if they are an exact or near-exact text match (use 'exact' for 'matchQuality'). If there are notable differences, they should be listed as discrepancies instead.** Avoid using 'inferred' for these specific fields unless the evidence is overwhelmingly strong across multiple related sub-fields and you explicitly state the basis of this strong inference in the 'comparisonNotes' or overall 'summary'. If in doubt about a match for such critical fields, list it as a discrepancy.

**2. Detailed Product Line Item Comparison (for 'productLineItemComparisons' array):**
   - Perform a detailed comparison of product line items between the SO and the **first PO (if one was provided and processed)**. For each product line item found in the SO, try to find its corresponding item in the first PO (and vice-versa). Strive to find the best possible match for product descriptions, even if there are minor wording differences, acronyms, or variations in item codes/SKUs. Focus on semantic similarity where appropriate.
   - If no PO was provided, all SO line items should be marked as 'SO_ONLY'.
   - For each identified product line item pairing (or an item found only in one document):
     - Once a potential product pairing is identified based on description/SKU, you *must* then thoroughly compare their respective quantities, unit prices, and total prices to determine the correct status. Do not assume a full match based on description alone; all corresponding details for that line item must be scrutinized.
     - Extract 'poProductDescription', 'poQuantity', 'poUnitPrice', 'poTotalPrice' from the **first PO (if available)**. Use "N/A" or "No PO Provided" if the item is SO_ONLY, no PO was provided, or if a specific detail is not present/extractable from the PO line item.
     - Extract 'soProductDescription', 'soQuantity', 'soUnitPrice', 'soTotalPrice' from the SO. Use "N/A" if the item is PO_ONLY or if a specific detail is not present/extractable from the SO line item.
     - Determine a 'status':
       - 'MATCHED': If description, quantity, and prices (unit and total, or equivalent if one is missing but calculable) appear to match closely or are equivalent between SO and first PO.
       - 'MISMATCH_QUANTITY': If quantities differ significantly.
       - 'MISMATCH_UNIT_PRICE': If unit prices differ significantly.
       - 'MISMATCH_TOTAL_PRICE': If total line item prices differ significantly (and unit price/qty might also be causes).
       - 'MISMATCH_DESCRIPTION': If products seem related (e.g., similar SKUs) but descriptions have notable, irreconcilable differences.
       - 'PO_ONLY': If the item is found only in the first Purchase Order and has no corresponding item in the Sales Order.
       - 'SO_ONLY': If the item is found only in the Sales Order and has no corresponding item in the first Purchase Order (or if no PO was provided).
       - 'PARTIAL_MATCH_DETAILS_DIFFER': If it's likely the same core product but some key details (other than quantity or price that would trigger a specific mismatch status) are inconsistent, or if the match is inferred with lower confidence.
     - Provide 'comparisonNotes': A brief explanation for the status (e.g., "Quantities differ (PO: 5, SO: 4)", "Unit prices mismatch", "Product found only in PO", "SO item, no PO provided for comparison").
   - Populate the 'productLineItemComparisons' array with these objects. If no product line items are found in either document (or only in SO and no PO provided), this array should reflect that (e.g., list SO items as SO_ONLY, or be empty if SO is also empty).

**3. Summary ('summary' field):**
   Provide a concise 'summary' of the overall comparison. This summary should highlight the most significant discrepancies from general fields (both document-level and unmatched products), key confirmed matches, and a brief overview of the product line item comparison findings (e.g., "3 product lines matched with first PO, 1 had quantity mismatch, 1 PO item not in SO"). If no PO was provided, state this clearly in the summary (e.g., "Sales Order processed. No Purchase Order was provided for comparison; all SO items are listed as SO_ONLY."). If any limitations were encountered processing the entirety of any document, you MUST explicitly state this limitation in your summary.

**Important Output Structure:**
- The 'discrepancies' array should always be present as a key in the root JSON object. If no general discrepancies are found, its value should be an empty array (\`[]\`).
- The 'matchedItems' array should always be present as a key in the root JSON object. If no general matches are found, its value should be an empty array (\`[]\`).
- The 'productLineItemComparisons' array should always be present as a key in the root JSON object. If no product line items are found or compared, its value should be an empty array (\`[]\`).
- The 'summary' field should always be present as a key in the root JSON object.
Ensure all fields in the output schema are populated according to your findings.
`,
  config: {
    safetySettings: [
      {
        category: 'HARM_CATEGORY_HARASSMENT',
        threshold: 'BLOCK_MEDIUM_AND_ABOVE',
      },
      {
        category: 'HARM_CATEGORY_HATE_SPEECH',
        threshold: 'BLOCK_MEDIUM_AND_ABOVE',
      },
      {
        category: 'HARM_CATEGORY_SEXUALLY_EXPLICIT',
        threshold: 'BLOCK_MEDIUM_AND_ABOVE',
      },
      {
        category: 'HARM_CATEGORY_DANGEROUS_CONTENT',
        threshold: 'BLOCK_ONLY_HIGH',
      },
    ],
    // Removed customHelpers and handlebarsOptions as they are no longer needed
  }
});

const compareOrderDetailsFlow = ai.defineFlow(
  {
    name: 'compareOrderDetailsFlow',
    inputSchema: CompareOrderDetailsInputSchema, // External input remains the same
    outputSchema: StrictCompareOrderDetailsOutputSchema, // Flow returns the strict schema
  },
  async (input): Promise<CompareOrderDetailsOutput> => {
    try {
      const poUris = input.purchaseOrderPdfDataUris || [];
      const internalPromptInput: InternalPromptInput = {
        salesOrderPdfDataUri: input.salesOrderPdfDataUri,
        hasPurchaseOrders: poUris.length > 0,
        firstPurchaseOrderPdfDataUri: poUris.length > 0 ? poUris[0] : undefined,
        totalPurchaseOrderCount: poUris.length,
        additionalPurchaseOrderUris: poUris.slice(1),
      };

      const { output: aiPermissiveOutput } = await compareOrderDetailsPrompt(internalPromptInput);

      if (!aiPermissiveOutput) {
        console.error('CompareOrderDetailsFlow: AI model returned null or undefined output payload.');
        throw new Error('AI model failed to return valid comparison data. Please check the documents or try again.');
      }
      
      const finalOutput: CompareOrderDetailsOutput = {
        discrepancies: Array.isArray(aiPermissiveOutput.discrepancies) ? aiPermissiveOutput.discrepancies : [],
        matchedItems: Array.isArray(aiPermissiveOutput.matchedItems) ? aiPermissiveOutput.matchedItems : [],
        productLineItemComparisons: Array.isArray(aiPermissiveOutput.productLineItemComparisons) ? aiPermissiveOutput.productLineItemComparisons : [],
        summary: typeof aiPermissiveOutput.summary === 'string' ? aiPermissiveOutput.summary : 'AI did not provide a summary for this comparison.',
      };
      
      return finalOutput;
    } catch (error: unknown) { 
      console.error("Error in compareOrderDetailsFlow: ", error);
      if (error instanceof Error) {
        if (error.message.includes("is not found for API version") || error.message.includes("API key not valid") || error.message.includes("Permission denied")) {
            throw new Error(`AI Model/API Key Error: ${error.message}. Please check model availability and API key permissions.`);
        }
        throw error;
      }
      throw new Error(String(error));
    }
  }
);

