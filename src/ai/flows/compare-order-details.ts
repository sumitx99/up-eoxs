
// This is an autogenerated file from Firebase Studio.

'use server';

/**
 * @fileOverview Compares product names, quantities, discounts, and taxes between a sales order document and one or more purchase order documents (PDF, image, CSV, or Excel) using AI.
 * If multiple Purchase Orders are provided, the AI is currently instructed to focus on the first one for detailed comparison against the Sales Order.
 * Identifies both discrepancies and matching items for overall fields, and provides a detailed comparison for product line items.
 *
 * - compareOrderDetails - Compares order details from document content and identifies discrepancies, matches, and detailed product line comparisons.
 * - CompareOrderDetailsInput - The input type for the compareOrderDetails function, expecting documents as data URIs.
 * - CompareOrderDetailsOutput - The output type for the compareOrderDetails function.
 * - MatchedItem - Type for general matched fields.
 * - Discrepancy - Type for general discrepancies.
 * - ProductLineItemComparison - Type for detailed product line item comparisons.
 */

import {ai} from '@/ai/genkit';
import {z} from 'genkit';

const CompareOrderDetailsInputSchema = z.object({
  salesOrderPdfDataUri: z.string().describe("The sales order document (PDF, image, CSV, or Excel) as a data URI. Expected format: 'data:<mimetype>;base64,<encoded_data>'."),
  purchaseOrderPdfDataUris: z.array(z.string()).describe("An array of purchase order documents (PDF, image, CSV, or Excel) as data URIs. Expected format: 'data:<mimetype>;base64,<encoded_data>'. Can be an empty array if no POs are linked or found."),
});
export type CompareOrderDetailsInput = z.infer<typeof CompareOrderDetailsInputSchema>;

// New internal schema for the prompt after data pre-processing
const InternalPromptInputSchema = z.object({
  salesOrderPdfDataUri: z.string(),
  firstPurchaseOrderPdfDataUri: z.string().optional(),
  hasPurchaseOrders: z.boolean(),
  totalPurchaseOrderCount: z.number(),
  additionalPurchaseOrderUris: z.array(z.string()),
  isSinglePO: z.boolean(),
  hasAdditionalPOs: z.boolean(),
  additionalPOCount: z.number(),
});
type InternalPromptInput = z.infer<typeof InternalPromptInputSchema>;


const DiscrepancySchema = z.object({
  field: z.string().describe('The general document field with a discrepancy (e.g., PO Number, Overall Discount, Payment Terms, Buyer Name, Shipping Address, or an unmatched product). This is for non-product line items or for flagging products found in one order but not the other.'),
  purchaseOrderValue: z.string().describe('The value from the purchase order document (or the first PO if multiple were provided). For an unmatched SO product, this might be "Desc: [SO Product Description], Qty: [SO Quantity], Unit Price: [SO Unit Price]" or similar if only found in SO, or simply "N/A" or "No PO Provided".'),
  salesOrderValue: z.string().describe('The value from the sales order document. For an unmatched PO product, this might be "Desc: [PO Product Description], Qty: [PO Quantity], Unit Price: [PO Unit Price]" or similar if only found in PO, or simply "N/A".'),
  reason: z.string().describe('The reason for the discrepancy, or why it might be a mismatch (e.g., "Quantities differ", "Product found only in PO", "Buyer names differ").'),
});
export type Discrepancy = z.infer<typeof DiscrepancySchema>;


const MatchedItemSchema = z.object({
  field: z.string().describe('The general document field that matches (e.g., PO Number, Vendor Name, Order Date). This is for non-product line items.'),
  value: z.string().describe('The common value found in both the sales order and the (first) purchase order document.'),
  matchQuality: z.enum(['exact', 'normalized', 'inferred']).optional().describe('The quality of the match (e.g., exact string match, match after normalization, or inferred match based on context). Default to "exact" if not specified.'),
});
export type MatchedItem = z.infer<typeof MatchedItemSchema>;

const ProductLineItemComparisonSchema = z.object({
  poProductDescription: z.string().optional().describe('Product name, description, or SKU from the Purchase Order line item (first PO if multiple provided). Use "N/A" if the item is SO_ONLY, no PO was provided, or if this specific detail is not present/extractable from the PO line item.'),
  poQuantity: z.string().optional().describe('Quantity from the Purchase Order line item. Use "N/A" if the item is SO_ONLY, no PO provided, or if this specific detail is not present/extractable.'),
  poUnitPrice: z.string().optional().describe('Unit price from the Purchase Order line item. Use "N/A" if the item is SO_ONLY, no PO provided, or if this specific detail is not present/extractable.'),
  poTotalPrice: z.string().optional().describe('Total price for the line item from the Purchase Order. Use "N/A" if the item is SO_ONLY, no PO provided, or if this specific detail is not present/extractable.'),
  soProductDescription: z.string().optional().describe('Product name, description, or SKU from the Sales Order line item. Use "N/A" if the item is PO_ONLY or if this specific detail is not present/extractable from the SO line item.'),
  soQuantity: z.string().optional().describe('Quantity from the Sales Order line item. Use "N/A" if the item is PO_ONLY or if this specific detail is not present/extractable.'),
  soUnitPrice: z.string().optional().describe('Unit price from the Sales Order line item. Use "N/A" if the item is PO_ONLY or if this specific detail is not present/extractable.'),
  soTotalPrice: z.string().optional().describe('Total price for the line item from the Sales Order. Use "N/A" if the item is PO_ONLY or if this specific detail is not present/extractable.'),
  status: z.enum(['MATCHED', 'MISMATCH_QUANTITY', 'MISMATCH_UNIT_PRICE', 'MISMATCH_TOTAL_PRICE', 'MISMATCH_DESCRIPTION', 'PO_ONLY', 'SO_ONLY', 'PARTIAL_MATCH_DETAILS_DIFFER']).describe('The comparison status for this product line item pairing.'),
  comparisonNotes: z.string().describe('AI\'s brief notes explaining the status or highlighting specific differences for this line item (e.g., "Quantities differ", "Unit prices mismatch", "Product found only in PO", "No PO document provided for comparison").'),
});
export type ProductLineItemComparison = z.infer<typeof ProductLineItemComparisonSchema>;

const StrictCompareOrderDetailsOutputSchema = z.object({
  discrepancies: z.array(DiscrepancySchema).describe('An array of general discrepancies found (e.g., for header fields, overall totals, terms, or unmatched products). This should always be an array, even if empty.'),
  matchedItems: z.array(MatchedItemSchema).describe('An array of general items/fields that match (e.g., for header fields). This should always be an array, even if empty. Strive to find matches for common header fields.'),
  productLineItemComparisons: z.array(ProductLineItemComparisonSchema).describe('An array detailing the comparison of each product line item found in the documents. This should always be an array, even if empty.'),
  summary: z.string().describe('A summary of the overall comparison, highlighting key discrepancies, confirmed matches, and product line item findings. If any limitations were encountered processing the entirety of any document, or if no PO was provided, this must be noted here.'),
});
export type CompareOrderDetailsOutput = z.infer<typeof StrictCompareOrderDetailsOutputSchema>;

const AiPermissiveOutputSchema = z.object({
  discrepancies: z.array(DiscrepancySchema).optional().describe('An array of general discrepancies found (e.g., for header fields, overall totals, terms, or unmatched products).'),
  matchedItems: z.array(MatchedItemSchema).optional().describe('An array of general items/fields that match (e.g., for header fields). Strive to find matches for common header fields.'),
  productLineItemComparisons: z.array(ProductLineItemComparisonSchema).optional().describe('An array detailing the comparison of each product line item found in the documents.'),
  summary: z.string().optional().describe('A summary of the overall comparison, highlighting key discrepancies, confirmed matches, and product line item findings. If any limitations were encountered processing the entirety of any document, or if no PO was provided, this must be noted here.'),
});


export async function compareOrderDetails(input: CompareOrderDetailsInput): Promise<CompareOrderDetailsOutput> {
  return compareOrderDetailsFlow(input);
}

const compareOrderDetailsPrompt = ai.definePrompt({
  name: 'compareOrderDetailsPrompt',
  input: {
    schema: InternalPromptInputSchema, 
  },
  output: {
    schema: AiPermissiveOutputSchema, 
  },
  prompt: `You are an AI assistant specializing in comparing sales orders (SOs) with associated purchase orders (POs) provided as various document types.
Your task is to meticulously analyze the **entire content** of all provided documents, from start to finish, including all pages, headers, footers, and line items.
It is absolutely critical for the accuracy of this task that every piece of information, from all pages and all sections of all documents, is meticulously reviewed and considered. Incomplete analysis or overlooking any part of the documents will lead to incorrect and unusable results. Do not stop processing part-way through a document.

The documents can be in PDF, image (e.g., JPEG, PNG), CSV, or Excel (XLS, XLSX) format.
- If the document is an image, perform OCR to extract textual content.
- If the document is a CSV or Excel file, parse the tabular data to identify order details. Look for headers like 'Product', 'Item', 'Quantity', 'Price', 'Amount', 'Discount', 'Tax', 'PO Number', 'Buyer', 'Vendor', 'Payment Terms', etc.
- If the document is a PDF, extract its textual content thoroughly from all pages.

**Initial Document Sanity Check:** Before detailed analysis, you must first inspect the provided documents. If a document's content appears to be an HTML page (e.g., contains \`<!DOCTYPE html>\`, \`<html>\`, etc.), particularly a login or error page, instead of a proper order document, you **MUST NOT** attempt to extract order details from it. Instead, you must report this problem in the 'summary' field. For example, if the Sales Order is an HTML page, your summary should start with: "The Sales Order document provided was an HTML page, not a valid order document. This typically indicates an ERP connection or authentication error." Then, treat that document as if it were not provided for the rest of the comparison.

Analyze the content of the following Sales Order document and any provided Purchase Order documents, keeping the sanity check in mind:
Ensure you process all pages and sections of each document.

Sales Order Document:
{{media url=salesOrderPdfDataUri}}

Purchase Order Document(s):
{{#if hasPurchaseOrders}}
  {{#if firstPurchaseOrderPdfDataUri}}
    {{#if isSinglePO}}
      A single Purchase Order document is provided:
      {{media url=firstPurchaseOrderPdfDataUri}}
      You will compare this Purchase Order against the Sales Order.
    {{else}} {{! This means totalPurchaseOrderCount > 1 }}
      Multiple ({{totalPurchaseOrderCount}}) Purchase Order documents are provided. For this comparison, **focus primarily on the FIRST Purchase Order document listed below** when comparing line items and specific PO values against the Sales Order. You may reference other POs for context if it helps clarify discrepancies or matches related to the first PO, but the detailed values (quantities, prices) reported for 'purchaseOrderValue' or 'poProductDescription' etc., should come from the first PO.
      First Purchase Order Document:
      {{media url=firstPurchaseOrderPdfDataUri}}

      {{#if hasAdditionalPOs}}
        Additional Purchase Order Documents ({{additionalPOCount}} for context, less detailed focus):
        {{#each additionalPurchaseOrderUris}}
          Additional PO (Context): {{media url=this}}
        {{/each}}
      {{/if}}
    {{/if}}
  {{else}} 
    A Purchase Order document was expected (count: {{totalPurchaseOrderCount}}), but the primary PO document could not be processed or was empty. Please verify the linked Purchase Order documents in the ERP.
    The Sales Order will be analyzed as if no valid Purchase Order was available. For any fields or items that would normally come from a Purchase Order, indicate "N/A - PO Not Processed" or similar. All Sales Order line items should be treated as 'SO_ONLY'. Note the absence of a usable PO in your summary.
  {{/if}}
{{else}}
  No Purchase Order document was provided for comparison. Proceed with analyzing the Sales Order. For any fields or items that would normally come from a Purchase Order, indicate "N/A - No PO Provided" or similar. All Sales Order line items should be treated as 'SO_ONLY'. 
  Your summary should state: "Sales Order processed. No Purchase Order was provided for comparison; all SO items are listed as SO_ONLY."
{{/if}}

Based on your analysis of the document contents, provide the following in a valid JSON format:

**1. General Document Field Comparison (for 'discrepancies' and 'matchedItems' arrays):**
   (Instructions for this section remain largely the same, but remember to specify "first PO", "No PO Provided", or "PO Not Processed" where applicable)

   **A. Document-Level Field Discrepancies:**
      - Meticulously compare **general document fields that are NOT product line items** between the Sales Order and the **first Purchase Order (if provided and processed)**. These include, but are not limited to: PO Number, Order Date, Buyer/Seller names and addresses, Shipping/Billing addresses, Payment Terms, Shipping Terms, Incoterms, overall document Subtotals, overall Taxes, overall Discounts, and Grand Totals.
      - **Pay extremely close attention to Buyer/Customer names and their full addresses (Shipping and Billing). Even minor differences in names (e.g., 'Titan Steel Works' vs. 'Steel America') or any significant differences in address components (street, city, state, zip code) MUST be flagged as discrepancies.** Do not assume entities are the same if their names or addresses show such variations.
      - For any discrepancies found in these **document-level fields**, populate the 'discrepancies' array with objects specifying: 'field' (e.g., "Payment Terms", "Grand Total", "Buyer Address", "Buyer Name"), 'purchaseOrderValue' (from first PO, or "No PO Provided", or "PO Not Processed"), 'salesOrderValue', and 'reason' for the discrepancy (e.g., "Buyer names differ", "Shipping addresses do not match").

   **B. Unmatched Product Line Item Discrepancies:**
      - During your detailed product line item analysis (detailed in section 2 below), you will identify some products as 'PO_ONLY' or 'SO_ONLY'.
      - For these **unmatched products**, you must also add an entry to this 'discrepancies' array.
      - For items found in the **first PO (if provided and processed)** but not in the SO: 
        'field': "Unmatched PO Product: [Product Name/SKU from PO line item]", 
        'purchaseOrderValue': "Desc: [Product Name/SKU from PO line item], Qty: [Quantity from PO line item], Unit Price: [Unit Price from PO line item]", 
        'salesOrderValue': "Not found in SO", 
        'reason': "Product listed in Purchase Order only."
      - For items found in the SO but not in the **first PO (or if no PO provided/processed)**: 
        'field': "Unmatched SO Product: [Product Name/SKU from SO line item]", 
        'purchaseOrderValue': "Not found in PO" (or "No PO Provided", or "PO Not Processed"), 
        'salesOrderValue': "Desc: [Product Name/SKU from SO line item], Qty: [Quantity from SO line item], Unit Price: [Unit Price from SO line item]", 
        'reason': "Product listed in Sales Order only (or no usable PO to compare against)."
      - **Crucially, ensure that every product identified with a status of 'PO_ONLY' or 'SO_ONLY' during the detailed product line item analysis (section 2) results in a corresponding entry in this 'discrepancies' array (section 1).**

   **C. Matched General Document Fields:**
      - Identify general matching items/fields (non-product line items) between the SO and the **first PO (if provided and processed)**. For each, populate the 'matchedItems' array with objects specifying: 'field', 'value', 'matchQuality'. Strive to find matches for common header fields such as PO Number, Vendor Name, Order Dates, etc.
      - **For critical fields like Buyer names and full addresses, only list them as 'matchedItems' if they are an exact or near-exact text match (use 'exact' for 'matchQuality'). If there are notable differences, they should be listed as discrepancies instead.** Avoid using 'inferred' for these specific fields unless the evidence is overwhelmingly strong across multiple related sub-fields and you explicitly state the basis of this strong inference in the 'comparisonNotes' or overall 'summary'. If in doubt about a match for such critical fields, list it as a discrepancy.

**2. Detailed Product Line Item Comparison (for 'productLineItemComparisons' array):**
   - Perform a detailed comparison of product line items between the SO and the **first PO (if one was provided and processed)**. For each product line item found in the SO, try to find its corresponding item in the first PO (and vice-versa). Strive to find the best possible match for product descriptions, even if there are minor wording differences, acronyms, or variations in item codes/SKUs. Focus on semantic similarity where appropriate.
   - If no PO was provided or processed, all SO line items should be marked as 'SO_ONLY'.
   - For each identified product line item pairing (or an item found only in one document):
     - Once a potential product pairing is identified based on description/SKU, you *must* then thoroughly compare their respective quantities, unit prices, and total prices to determine the correct status. Do not assume a full match based on description alone; all corresponding details for that line item must be scrutinized.
     - Extract 'poProductDescription', 'poQuantity', 'poUnitPrice', 'poTotalPrice' from the **first PO (if available and processed)**. Use "N/A", "No PO Provided", or "PO Not Processed" if the item is SO_ONLY, no PO was provided/processed, or if a specific detail is not present/extractable from the PO line item.
     - Extract 'soProductDescription', 'soQuantity', 'soUnitPrice', 'soTotalPrice' from the SO. Use "N/A" if the item is PO_ONLY or if a specific detail is not present/extractable from the SO line item.
     - Determine a 'status':
       - 'MATCHED': If description, quantity, and prices (unit and total, or equivalent if one is missing but calculable) appear to match closely or are equivalent between SO and first PO.
       - 'MISMATCH_QUANTITY': If quantities differ significantly.
       - 'MISMATCH_UNIT_PRICE': If unit prices differ significantly.
       - 'MISMATCH_TOTAL_PRICE': If total line item prices differ significantly (and unit price/qty might also be causes).
       - 'MISMATCH_DESCRIPTION': If products seem related (e.g., similar SKUs) but descriptions have notable, irreconcilable differences.
       - 'PO_ONLY': If the item is found only in the first Purchase Order (and it was processed) and has no corresponding item in the Sales Order.
       - 'SO_ONLY': If the item is found only in the Sales Order and has no corresponding item in the first Purchase Order (or if no PO was provided/processed).
       - 'PARTIAL_MATCH_DETAILS_DIFFER': If it's likely the same core product but some key details (other than quantity or price that would trigger a specific mismatch status) are inconsistent, or if the match is inferred with lower confidence.
     - Provide 'comparisonNotes': A brief explanation for the status (e.g., "Quantities differ (PO: 5, SO: 4)", "Unit prices mismatch", "Product found only in PO", "SO item, no PO provided for comparison", "SO item, PO not processed").
   - Populate the 'productLineItemComparisons' array with these objects. If no product line items are found in either document (or only in SO and no PO provided/processed), this array should reflect that (e.g., list SO items as SO_ONLY, or be empty if SO is also empty).

**3. Summary ('summary' field):**
   Provide a concise 'summary' of the overall comparison. This summary should highlight the most significant discrepancies from general fields (both document-level and unmatched products), key confirmed matches, and a brief overview of the product line item comparison findings (e.g., "3 product lines matched with first PO, 1 had quantity mismatch, 1 PO item not in SO"). If no PO was provided, use the exact phrase: "Sales Order processed. No Purchase Order was provided for comparison; all SO items are listed as SO_ONLY." If a PO was expected but could not be processed, note this (e.g., "Sales Order processed. A Purchase Order was expected but could not be processed; comparison proceeded with SO only."). If any limitations were encountered processing the entirety of any document, you MUST explicitly state this limitation in your summary.

**Important Output Structure:**
- The 'discrepancies' array should always be present as a key in the root JSON object. If no general discrepancies are found, its value should be an empty array (\`[]\`).
- The 'matchedItems' array should always be present as a key in the root JSON object. If no general matches are found, its value should be an empty array (\`[]\`).
- The 'productLineItemComparisons' array should always be present as a key in the root JSON object. If no product line items are found or compared, its value should be an empty array (\`[]\`).
- The 'summary' field should always be present as a key in the root JSON object.
Ensure all fields in the output schema are populated according to your findings.
`,
  config: {
    safetySettings: [
      {
        category: 'HARM_CATEGORY_HARASSMENT',
        threshold: 'BLOCK_MEDIUM_AND_ABOVE',
      },
      {
        category: 'HARM_CATEGORY_HATE_SPEECH',
        threshold: 'BLOCK_MEDIUM_AND_ABOVE',
      },
      {
        category: 'HARM_CATEGORY_SEXUALLY_EXPLICIT',
        threshold: 'BLOCK_MEDIUM_AND_ABOVE',
      },
      {
        category: 'HARM_CATEGORY_DANGEROUS_CONTENT',
        threshold: 'BLOCK_ONLY_HIGH',
      },
    ],
  }
});

const isValidDataUri = (uri: string): boolean => {
  // Basic check: starts with 'data:', contains ';base64,', and has some content after base64,
  // This check is for any MIME type.
  return typeof uri === 'string' && uri.startsWith('data:') && uri.includes(';base64,') && uri.split(';base64,')[1]?.length > 0;
};

const compareOrderDetailsFlow = ai.defineFlow(
  {
    name: 'compareOrderDetailsFlow',
    inputSchema: CompareOrderDetailsInputSchema,
    outputSchema: StrictCompareOrderDetailsOutputSchema,
  },
  async (input): Promise<CompareOrderDetailsOutput> => {
    try {
      if (!isValidDataUri(input.salesOrderPdfDataUri)) {
        console.error('CompareOrderDetailsFlow: Invalid Sales Order data URI provided.');
        throw new Error('The Sales Order document is missing or invalid. Please ensure it is correctly processed and provided as a valid data URI.');
      }

      const validPoUris = (input.purchaseOrderPdfDataUris || []).filter(uri => {
        const isValid = isValidDataUri(uri);
        if (!isValid && typeof uri === 'string' && uri.length > 0) { // Log if it's a non-empty string but not a valid data URI
          console.warn(`CompareOrderDetailsFlow: Filtering out invalid or empty Purchase Order data URI: "${uri.substring(0,50)}..."`);
        }
        return isValid;
      });
      
      const additionalPOs = validPoUris.slice(1);
      const internalPromptInput: InternalPromptInput = {
        salesOrderPdfDataUri: input.salesOrderPdfDataUri,
        hasPurchaseOrders: validPoUris.length > 0,
        firstPurchaseOrderPdfDataUri: validPoUris.length > 0 ? validPoUris[0] : undefined,
        totalPurchaseOrderCount: validPoUris.length,
        additionalPurchaseOrderUris: additionalPOs,
        isSinglePO: validPoUris.length === 1,
        hasAdditionalPOs: additionalPOs.length > 0,
        additionalPOCount: additionalPOs.length,
      };

      const { output: aiPermissiveOutput } = await compareOrderDetailsPrompt(internalPromptInput);

      if (!aiPermissiveOutput) {
        console.error('CompareOrderDetailsFlow: AI model returned null or undefined output payload.');
        throw new Error('AI model failed to return valid comparison data. This might be due to an issue with the AI service or unprocessable document content.');
      }
      
      const finalOutput: CompareOrderDetailsOutput = {
        discrepancies: Array.isArray(aiPermissiveOutput.discrepancies) ? aiPermissiveOutput.discrepancies : [],
        matchedItems: Array.isArray(aiPermissiveOutput.matchedItems) ? aiPermissiveOutput.matchedItems : [],
        productLineItemComparisons: Array.isArray(aiPermissiveOutput.productLineItemComparisons) ? aiPermissiveOutput.productLineItemComparisons : [],
        summary: typeof aiPermissiveOutput.summary === 'string' ? aiPermissiveOutput.summary : 'AI did not provide a summary for this comparison.',
      };
      
      return finalOutput;
    } catch (error: unknown) { 
      console.error("Error in compareOrderDetailsFlow: ", error);
      let errorMessage = "An unexpected error occurred in the AI flow.";
      if (error instanceof Error) {
          errorMessage = error.message;
          if (errorMessage.includes("Converting circular structure to JSON")) {
              errorMessage = "An internal error occurred while processing the AI request. The AI service may have encountered an issue with the data structure. Please try again or check the document contents.";
          } else if (errorMessage.toLowerCase().includes("must supply a `contenttype`")) {
               errorMessage = "An error occurred with document processing for the AI: A document was provided without a recognized type. Please ensure all uploaded files are valid and have standard file extensions (e.g., .pdf, .png, .jpg, .csv).";
          } else if (errorMessage.toLowerCase().includes("request payload size exceeds the limit") || errorMessage.toLowerCase().includes("payload is too large")) {
              errorMessage = "One or more documents are too large for the AI to process. Please try with smaller files or fewer documents.";
          } else if (errorMessage.toLowerCase().includes("deadline exceeded") || errorMessage.toLowerCase().includes("timeout")) {
              errorMessage = "The AI service timed out while processing the documents. This may be due to complex documents or a temporary service issue. Please try again later.";
          } else if (errorMessage.includes("is not found for API version") || errorMessage.includes("API key not valid") || errorMessage.includes("Permission denied")) {
            errorMessage = `AI Model/API Key Error: ${errorMessage}. Please check model availability and API key permissions.`;
          }
      } else {
        errorMessage = String(error);
      }
      // Throw a new error with the potentially more user-friendly message
      throw new Error(`An error occurred in the AI flow: ${errorMessage}`);
    }
  }
);

