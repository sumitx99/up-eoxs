
// This is an autogenerated file from Firebase Studio.

'use server';

/**
 * @fileOverview Compares product names, quantities, discounts, and taxes between a purchase order and a sales order document (PDF, image, CSV, or Excel) using AI.
 * Identifies both discrepancies and matching items for overall fields, and provides a detailed comparison for product line items.
 *
 * - compareOrderDetails - Compares order details from document content and identifies discrepancies, matches, and detailed product line comparisons.
 * - CompareOrderDetailsInput - The input type for the compareOrderDetails function, expecting documents as data URIs.
 * - CompareOrderDetailsOutput - The output type for the compareOrderDetails function.
 * - MatchedItem - Type for general matched fields.
 * - Discrepancy - Type for general discrepancies.
 * - ProductLineItemComparison - Type for detailed product line item comparisons.
 */

import {ai} from '@/ai/genkit';
import {z} from 'genkit';

const CompareOrderDetailsInputSchema = z.object({
  purchaseOrder: z.string().describe("The purchase order document (PDF, image, CSV, or Excel) as a data URI. Expected format: 'data:<mimetype>;base64,<encoded_data>'."),
  salesOrder: z.string().describe("The sales order document (PDF, image, CSV, or Excel) as a data URI. Expected format: 'data:<mimetype>;base64,<encoded_data>'."),
});
export type CompareOrderDetailsInput = z.infer<typeof CompareOrderDetailsInputSchema>;

const DiscrepancySchema = z.object({
  field: z.string().describe('The general document field with a discrepancy (e.g., PO Number, Overall Discount, Payment Terms, or an unmatched product). This is for non-product line items or for flagging products found in one order but not the other.'),
  purchaseOrderValue: z.string().describe('The value from the purchase order document. For an unmatched SO product, this might be "N/A" or similar.'),
  salesOrderValue: z.string().describe('The value from the sales order document. For an unmatched PO product, this might be "N/A" or similar.'),
  reason: z.string().describe('The reason for the discrepancy, or why it might be a mismatch (e.g., "Quantities differ", "Product found only in PO").'),
});
export type Discrepancy = z.infer<typeof DiscrepancySchema>;


const MatchedItemSchema = z.object({
  field: z.string().describe('The general document field that matches (e.g., PO Number, Buyer Name, Vendor). This is for non-product line items.'),
  value: z.string().describe('The common value found in both the purchase order and sales order documents.'),
  matchQuality: z.enum(['exact', 'normalized', 'inferred']).optional().describe('The quality of the match (e.g., exact string match, match after normalization, or inferred match based on context). Default to "exact" if not specified.'),
});
export type MatchedItem = z.infer<typeof MatchedItemSchema>;

const ProductLineItemComparisonSchema = z.object({
  poProductDescription: z.string().optional().describe('Product name, description, or SKU from the Purchase Order line item. Use "N/A" if the item is SO_ONLY or if this specific detail is not present/extractable from the PO line item.'),
  poQuantity: z.string().optional().describe('Quantity from the Purchase Order line item. Use "N/A" if the item is SO_ONLY or if this specific detail is not present/extractable.'),
  poUnitPrice: z.string().optional().describe('Unit price from the Purchase Order line item. Use "N/A" if the item is SO_ONLY or if this specific detail is not present/extractable.'),
  poTotalPrice: z.string().optional().describe('Total price for the line item from the Purchase Order. Use "N/A" if the item is SO_ONLY or if this specific detail is not present/extractable.'),
  soProductDescription: z.string().optional().describe('Product name, description, or SKU from the Sales Order line item. Use "N/A" if the item is PO_ONLY or if this specific detail is not present/extractable from the SO line item.'),
  soQuantity: z.string().optional().describe('Quantity from the Sales Order line item. Use "N/A" if the item is PO_ONLY or if this specific detail is not present/extractable.'),
  soUnitPrice: z.string().optional().describe('Unit price from the Sales Order line item. Use "N/A" if the item is PO_ONLY or if this specific detail is not present/extractable.'),
  soTotalPrice: z.string().optional().describe('Total price for the line item from the Sales Order. Use "N/A" if the item is PO_ONLY or if this specific detail is not present/extractable.'),
  status: z.enum(['MATCHED', 'MISMATCH_QUANTITY', 'MISMATCH_UNIT_PRICE', 'MISMATCH_TOTAL_PRICE', 'MISMATCH_DESCRIPTION', 'PO_ONLY', 'SO_ONLY', 'PARTIAL_MATCH_DETAILS_DIFFER']).describe('The comparison status for this product line item pairing.'),
  comparisonNotes: z.string().describe('AI\'s brief notes explaining the status or highlighting specific differences for this line item (e.g., "Quantities differ", "Unit prices mismatch", "Product found only in PO").'),
});
export type ProductLineItemComparison = z.infer<typeof ProductLineItemComparisonSchema>;

const CompareOrderDetailsOutputSchema = z.object({
  discrepancies: z.array(DiscrepancySchema).describe('An array of general discrepancies found (e.g., for header fields, overall totals, terms, or unmatched products). This should always be an array, even if empty.'),
  matchedItems: z.array(MatchedItemSchema).describe('An array of general items/fields that match (e.g., for header fields). This should always be an array, even if empty. Strive to find matches for common header fields.'),
  productLineItemComparisons: z.array(ProductLineItemComparisonSchema).describe('An array detailing the comparison of each product line item found in the documents. This should always be an array, even if empty.'),
  summary: z.string().describe('A summary of the overall comparison, highlighting key discrepancies, confirmed matches, and product line item findings. If any limitations were encountered processing the entirety of any document, this must be noted here.'),
});

export type CompareOrderDetailsOutput = z.infer<typeof CompareOrderDetailsOutputSchema>;

export async function compareOrderDetails(input: CompareOrderDetailsInput): Promise<CompareOrderDetailsOutput> {
  return compareOrderDetailsFlow(input);
}

const compareOrderDetailsPrompt = ai.definePrompt({
  name: 'compareOrderDetailsPrompt',
  input: {
    schema: CompareOrderDetailsInputSchema,
  },
  output: {
    schema: CompareOrderDetailsOutputSchema,
  },
  prompt: `You are an AI assistant specializing in comparing purchase orders (POs) and sales orders (SOs) provided as various document types.
Your task is to meticulously analyze the **entire content** of both documents, from start to finish, including all pages, headers, footers, and line items.
It is absolutely critical for the accuracy of this task that every piece of information, from all pages and all sections of both documents, is meticulously reviewed and considered. Incomplete analysis or overlooking any part of the documents will lead to incorrect and unusable results. Do not stop processing part-way through a document.

The documents can be in PDF, image (e.g., JPEG, PNG), CSV, or Excel (XLS, XLSX) format.
- If the document is an image, perform OCR to extract textual content.
- If the document is a CSV or Excel file, parse the tabular data to identify order details. Look for headers like 'Product', 'Item', 'Quantity', 'Price', 'Amount', 'Discount', 'Tax', 'PO Number', 'Buyer', 'Vendor', 'Payment Terms', etc.
- If the document is a PDF, extract its textual content thoroughly from all pages.

Analyze the content of the following Purchase Order document and Sales Order document:
Ensure you process all pages and sections of each document.
Purchase Order Document:
{{media url=purchaseOrder}}

Sales Order Document:
{{media url=salesOrder}}

Based on your analysis of the document contents, provide the following:

**1. General Document Field Comparison (for 'discrepancies' and 'matchedItems' arrays):**

   **A. Document-Level Field Discrepancies:**
      - Meticulously compare **general document fields that are NOT product line items**. These include, but are not limited to: PO Number, Order Date, Buyer/Seller names and addresses, Shipping/Billing addresses, Payment Terms, Shipping Terms, Incoterms, overall document Subtotals, overall Taxes, overall Discounts, and Grand Totals.
      - For any discrepancies found in these **document-level fields**, populate the 'discrepancies' array with objects specifying: 'field' (e.g., "Payment Terms", "Grand Total", "Buyer Address"), 'purchaseOrderValue', 'salesOrderValue', and 'reason' for the discrepancy.

   **B. Unmatched Product Line Item Discrepancies:**
      - During your detailed product line item analysis (detailed in section 2 below), you will identify some products as 'PO_ONLY' or 'SO_ONLY'.
      - For these **unmatched products**, you must also add an entry to this 'discrepancies' array.
      - For items found in the PO but not in the SO: 
        'field': "Unmatched PO Product: [Product Name/SKU from PO line item]", 
        'purchaseOrderValue': "Desc: [Product Name/SKU from PO line item], Qty: [Quantity from PO line item], Unit Price: [Unit Price from PO line item]", 
        'salesOrderValue': "Not found in SO", 
        'reason': "Product listed in Purchase Order only."
      - For items found in the SO but not in the PO: 
        'field': "Unmatched SO Product: [Product Name/SKU from SO line item]", 
        'purchaseOrderValue': "Not found in PO", 
        'salesOrderValue': "Desc: [Product Name/SKU from SO line item], Qty: [Quantity from SO line item], Unit Price: [Unit Price from SO line item]", 
        'reason': "Product listed in Sales Order only."
      - **Critically, ensure that every product identified with a status of 'PO_ONLY' or 'SO_ONLY' in section 2 results in a corresponding entry here in section 1B.**

   **C. Matched General Document Fields:**
      - Identify general matching items/fields (non-product line items). For each, populate the 'matchedItems' array with objects specifying: 'field', 'value', 'matchQuality'. Strive to find matches for common header fields such as PO Number, Buyer Name, Vendor Name, Order Dates, etc.

**2. Detailed Product Line Item Comparison (for 'productLineItemComparisons' array):**
   - Perform a detailed comparison of product line items. For each product line item found in the PO, try to find its corresponding item in the SO (and vice-versa). Strive to find the best possible match for product descriptions, even if there are minor wording differences, acronyms, or variations in item codes/SKUs. Focus on semantic similarity where appropriate.
   - For each identified product line item pairing (or an item found only in one document):
     - Once a potential product pairing is identified based on description/SKU, you *must* then thoroughly compare their respective quantities, unit prices, and total prices to determine the correct status. Do not assume a full match based on description alone; all corresponding details for that line item must be scrutinized.
     - Extract 'poProductDescription', 'poQuantity', 'poUnitPrice', 'poTotalPrice' from the PO. Use "N/A" if the item is SO_ONLY or if a specific detail is not present/extractable from the PO line item.
     - Extract 'soProductDescription', 'soQuantity', 'soUnitPrice', 'soTotalPrice' from the SO. Use "N/A" if the item is PO_ONLY or if a specific detail is not present/extractable from the SO line item.
     - Determine a 'status':
       - 'MATCHED': If description, quantity, and prices (unit and total, or equivalent if one is missing but calculable) appear to match closely or are equivalent.
       - 'MISMATCH_QUANTITY': If quantities differ significantly.
       - 'MISMATCH_UNIT_PRICE': If unit prices differ significantly.
       - 'MISMATCH_TOTAL_PRICE': If total line item prices differ significantly (and unit price/qty might also be causes).
       - 'MISMATCH_DESCRIPTION': If products seem related (e.g., similar SKUs) but descriptions have notable, irreconcilable differences.
       - 'PO_ONLY': If the item is found only in the Purchase Order and has no corresponding item in the Sales Order.
       - 'SO_ONLY': If the item is found only in the Sales Order and has no corresponding item in the Purchase Order.
       - 'PARTIAL_MATCH_DETAILS_DIFFER': If it's likely the same core product but some key details (other than quantity or price that would trigger a specific mismatch status) are inconsistent, or if the match is inferred with lower confidence.
     - Provide 'comparisonNotes': A brief explanation for the status (e.g., "Quantities differ (PO: 5, SO: 4)", "Unit prices mismatch", "Product found only in PO", "Description slightly different but quantities match").
   - Populate the 'productLineItemComparisons' array with these objects. If no product line items are found in either document, this array should be empty.

**3. Summary ('summary' field):**
   Provide a concise 'summary' of the overall comparison. This summary should highlight the most significant discrepancies from general fields (both document-level and unmatched products), key confirmed matches, and a brief overview of the product line item comparison findings (e.g., "3 product lines matched, 1 had quantity mismatch, 1 PO item not in SO"). If no general discrepancies (non-product related) were found, explicitly state this. If any limitations were encountered processing the entirety of either document, you MUST explicitly state this limitation in your summary.

**Important Output Structure:**
- The 'discrepancies' array should always be present. If no general discrepancies are found, it should be an empty array (\`[]\`).
- The 'matchedItems' array should always be present. If no general matches are found, it should be an empty array (\`[]\`).
- The 'productLineItemComparisons' array should always be present. If no product line items are found or compared, it should be an empty array (\`[]\`).

Be thorough, accurate, and **process all provided content from all document types**. If the document content is unreadable, ambiguous, or crucial sections are missing, note this limitation in your summary.
Ensure all fields in the output schema are populated according to your findings.
`,
  config: {
    safetySettings: [
      {
        category: 'HARM_CATEGORY_HARASSMENT',
        threshold: 'BLOCK_MEDIUM_AND_ABOVE',
      },
      {
        category: 'HARM_CATEGORY_HATE_SPEECH',
        threshold: 'BLOCK_MEDIUM_AND_ABOVE',
      },
      {
        category: 'HARM_CATEGORY_SEXUALLY_EXPLICIT',
        threshold: 'BLOCK_MEDIUM_AND_ABOVE',
      },
      {
        category: 'HARM_CATEGORY_DANGEROUS_CONTENT',
        threshold: 'BLOCK_ONLY_HIGH',
      },
    ],
  }
});

const compareOrderDetailsFlow = ai.defineFlow(
  {
    name: 'compareOrderDetailsFlow',
    inputSchema: CompareOrderDetailsInputSchema,
    outputSchema: CompareOrderDetailsOutputSchema,
  },
  async input => {
    try {
      const {output} = await compareOrderDetailsPrompt(input);
      if (!output) {
        console.error('CompareOrderDetailsFlow: AI model returned null or undefined output.');
        throw new Error('AI model failed to return valid comparison data. Please check the documents or try again.');
      }
      // Ensure arrays are always present
      output.matchedItems = Array.isArray(output.matchedItems) ? output.matchedItems : [];
      output.discrepancies = Array.isArray(output.discrepancies) ? output.discrepancies : [];
      output.productLineItemComparisons = Array.isArray(output.productLineItemComparisons) ? output.productLineItemComparisons : [];
      
      return output;
    } catch (error) {
      console.error("Error in compareOrderDetailsFlow: ", error);
      let errorMessage = error instanceof Error ? error.message : String(error);
      
      if (errorMessage.toLowerCase().includes('model not found') || errorMessage.toLowerCase().includes('not found for api version')) {
          errorMessage = `The specified AI model is not accessible or does not exist. Please check the model name and API key permissions. Details: ${errorMessage}`;
      } else if (errorMessage.includes('CLIENT_ERROR') || 
                 errorMessage.toLowerCase().includes('unsupported mime type') || 
                 errorMessage.toLowerCase().includes('failed to parse content') || 
                 errorMessage.toLowerCase().includes('failed to parse content from bytes') || 
                 errorMessage.toLowerCase().includes('consumer_suspended') || 
                 errorMessage.toLowerCase().includes('permission denied') ||
                 errorMessage.toLowerCase().includes('api key not valid') ||
                 errorMessage.toLowerCase().includes('billing account')) { 
        errorMessage = `The AI model could not process one or both of the documents, or there's an issue with API access/billing. Please ensure documents are valid, the API key is correct, and your billing account is active. Details: ${errorMessage}`;
      } else {
        errorMessage = `The AI model encountered an issue during processing. This could be due to document complexity, content, or a temporary problem. Details: ${errorMessage}. Please try again or use different documents.`;
      }
      throw new Error(errorMessage);
    }
  }
);

    