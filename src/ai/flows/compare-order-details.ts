
// This is an autogenerated file from Firebase Studio.

'use server';

/**
 * @fileOverview Compares product names, quantities, discounts, and taxes between a sales order document and one or more purchase order documents (PDF, image, CSV, or Excel) using AI.
 * If multiple Purchase Orders are provided, the AI is currently instructed to focus on the first one for detailed comparison against the Sales Order.
 * Identifies both discrepancies and matching items for overall fields, and provides a detailed comparison for product line items.
 *
 * - compareOrderDetails - Compares order details from document content and identifies discrepancies, matches, and detailed product line comparisons.
 * - CompareOrderDetailsInput - The input type for the compareOrderDetails function, expecting documents as data URIs.
 * - CompareOrderDetailsOutput - The output type for the compareOrderDetails function.
 * - MatchedItem - Type for general matched fields.
 * - Discrepancy - Type for general discrepancies.
 * - ProductLineItemComparison - Type for detailed product line item comparisons.
 */

import {ai} from '@/ai/genkit';
import {z} from 'genkit';

const CompareOrderDetailsInputSchema = z.object({
  salesOrderPdfDataUri: z.string().describe("The sales order document (PDF, image, CSV, or Excel) as a data URI. Expected format: 'data:<mimetype>;base64,<encoded_data>'."),
  purchaseOrderPdfDataUris: z.array(z.string()).describe("An array of purchase order documents (PDF, image, CSV, or Excel) as data URIs. Expected format: 'data:<mimetype>;base64,<encoded_data>'. Can be an empty array if no POs are linked or found."),
});
export type CompareOrderDetailsInput = z.infer<typeof CompareOrderDetailsInputSchema>;

// New internal schema for the prompt after data pre-processing
const InternalPromptInputSchema = z.object({
  salesOrderPdfDataUri: z.string(),
  firstPurchaseOrderPdfDataUri: z.string().optional(),
  hasPurchaseOrders: z.boolean(),
  totalPurchaseOrderCount: z.number(),
  additionalPurchaseOrderUris: z.array(z.string()),
  // New booleans and count for simplified template logic
  isSinglePO: z.boolean(),
  hasAdditionalPOs: z.boolean(),
  additionalPOCount: z.number(),
});
type InternalPromptInput = z.infer<typeof InternalPromptInputSchema>;


const DiscrepancySchema = z.object({
  field: z.string().describe('The general document field with a discrepancy (e.g., PO Number, Overall Discount, Payment Terms, Buyer Name, Shipping Address, or an unmatched product). This is for non-product line items or for flagging products found in one order but not the other.'),
  purchaseOrderValue: z.string().describe('The value from the purchase order document (or the first PO if multiple were provided). For an unmatched SO product, this might be "Desc: [SO Product Description], Qty: [SO Quantity], Unit Price: [SO Unit Price]" or similar if only found in SO, or simply "N/A" or "No PO Provided".'),
  salesOrderValue: z.string().describe('The value from the sales order document. For an unmatched PO product, this might be "Desc: [PO Product Description], Qty: [PO Quantity], Unit Price: [PO Unit Price]" or similar if only found in PO, or simply "N/A".'),
  reason: z.string().describe('The reason for the discrepancy, or why it might be a mismatch (e.g., "Quantities differ", "Product found only in PO", "Buyer names differ").'),
});
export type Discrepancy = z.infer<typeof DiscrepancySchema>;


const MatchedItemSchema = z.object({
  field: z.string().describe('The general document field that matches (e.g., PO Number, Vendor Name, Order Date). This is for non-product line items.'),
  value: z.string().describe('The common value found in both the sales order and the (first) purchase order document.'),
  matchQuality: z.enum(['exact', 'normalized', 'inferred']).optional().describe('The quality of the match (e.g., exact string match, match after normalization, or inferred match based on context). Default to "exact" if not specified.'),
});
export type MatchedItem = z.infer<typeof MatchedItemSchema>;

const ProductLineItemComparisonSchema = z.object({
  poProductDescription: z.string().optional().describe('Product name, description, or SKU from the Purchase Order line item (first PO if multiple provided). Use "N/A" if the item is SO_ONLY, no PO was provided, or if this specific detail is not present/extractable from the PO line item.'),
  poQuantity: z.string().optional().describe('Quantity from the Purchase Order line item. Use "N/A" if the item is SO_ONLY, no PO provided, or if this specific detail is not present/extractable.'),
  poUnitPrice: z.string().optional().describe('Unit price from the Purchase Order line item. Use "N/A" if the item is SO_ONLY, no PO provided, or if this specific detail is not present/extractable.'),
  poTotalPrice: z.string().optional().describe('Total price for the line item from the Purchase Order. Use "N/A" if the item is SO_ONLY, no PO provided, or if this specific detail is not present/extractable.'),
  soProductDescription: z.string().optional().describe('Product name, description, or SKU from the Sales Order line item. Use "N/A" if the item is PO_ONLY or if this specific detail is not present/extractable from the SO line item.'),
  soQuantity: z.string().optional().describe('Quantity from the Sales Order line item. Use "N/A" if the item is PO_ONLY or if this specific detail is not present/extractable.'),
  soUnitPrice: z.string().optional().describe('Unit price from the Sales Order line item. Use "N/A" if the item is PO_ONLY or if this specific detail is not present/extractable.'),
  soTotalPrice: z.string().optional().describe('Total price for the line item from the Sales Order. Use "N/A" if the item is PO_ONLY or if this specific detail is not present/extractable.'),
  status: z.enum(['MATCHED', 'MISMATCH_QUANTITY', 'MISMATCH_UNIT_PRICE', 'MISMATCH_TOTAL_PRICE', 'MISMATCH_DESCRIPTION', 'PO_ONLY', 'SO_ONLY', 'PARTIAL_MATCH_DETAILS_DIFFER']).describe('The comparison status for this product line item pairing.'),
  comparisonNotes: z.string().describe('AI\'s brief notes explaining the status or highlighting specific differences for this line item (e.g., "Quantities differ", "Unit prices mismatch", "Product found only in PO", "No PO document provided for comparison").'),
});
export type ProductLineItemComparison = z.infer<typeof ProductLineItemComparisonSchema>;

// Strict schema for the flow's final output and the exported type
const StrictCompareOrderDetailsOutputSchema = z.object({
  discrepancies: z.array(DiscrepancySchema).describe('An array of general discrepancies found (e.g., for header fields, overall totals, terms, or unmatched products). This should always be an array, even if empty.'),
  matchedItems: z.array(MatchedItemSchema).describe('An array of general items/fields that match (e.g., for header fields). This should always be an array, even if empty. Strive to find matches for common header fields.'),
  productLineItemComparisons: z.array(ProductLineItemComparisonSchema).describe('An array detailing the comparison of each product line item found in the documents. This should always be an array, even if empty.'),
  summary: z.string().describe('A summary of the overall comparison, highlighting key discrepancies, confirmed matches, and product line item findings. If any limitations were encountered processing the entirety of any document, or if no PO was provided, this must be noted here.'),
});
export type CompareOrderDetailsOutput = z.infer<typeof StrictCompareOrderDetailsOutputSchema>;

// Permissive schema for the AI's direct output, allowing optional top-level array fields
const AiPermissiveOutputSchema = z.object({
  discrepancies: z.array(DiscrepancySchema).optional().describe('An array of general discrepancies found (e.g., for header fields, overall totals, terms, or unmatched products).'),
  matchedItems: z.array(MatchedItemSchema).optional().describe('An array of general items/fields that match (e.g., for header fields). Strive to find matches for common header fields.'),
  productLineItemComparisons: z.array(ProductLineItemComparisonSchema).optional().describe('An array detailing the comparison of each product line item found in the documents.'),
  summary: z.string().optional().describe('A summary of the overall comparison, highlighting key discrepancies, confirmed matches, and product line item findings. If any limitations were encountered processing the entirety of any document, or if no PO was provided, this must be noted here.'),
});


export async function compareOrderDetails(input: CompareOrderDetailsInput): Promise<CompareOrderDetailsOutput> {
  return compareOrderDetailsFlow(input);
}

const compareOrderDetailsPrompt = ai.definePrompt({
  name: 'compareOrderDetailsPrompt',
  input: {
    schema: InternalPromptInputSchema, // Use the new internal schema
  },
  output: {
    schema: AiPermissiveOutputSchema, // Use permissive schema for AI output
  },
  prompt: `You are an AI assistant specializing in comparing sales orders (SOs) with associated purchase orders (POs) provided as various document types.
Your task is to meticulously analyze the **entire content** of all provided documents, from start to finish, including all pages, headers, footers, and line items.
It is absolutely critical for the accuracy of this task that every piece of information, from all pages and all sections of all documents, is meticulously reviewed and considered. Incomplete analysis or overlooking any part of the documents will lead to incorrect and unusable results. Do not stop processing part-way through a document.

The documents can be in PDF, image (e.g., JPEG, PNG), CSV, or Excel (XLS, XLSX) format.
- If the document is an image, perform OCR to extract textual content.
- If the document is a CSV or Excel file, parse the tabular data to identify order details. Look for headers like 'Product', 'Item', 'Quantity', 'Price', 'Amount', 'Discount', 'Tax', 'PO Number', 'Buyer', 'Vendor', 'Payment Terms', etc.
- If the document is a PDF, extract its textual content thoroughly from all pages.

Analyze the content of the following Sales Order document and any provided Purchase Order documents:
Ensure you process all pages and sections of each document.

Sales Order Document (SO):
{{media url=salesOrderPdfDataUri}}

Purchase Order Document(s) (PO):
{{#if hasPurchaseOrders}}
  {{#if firstPurchaseOrderPdfDataUri}}
    {{#if isSinglePO}}
      A single Purchase Order document is provided:
      {{media url=firstPurchaseOrderPdfDataUri}}
      You will compare this Purchase Order against the Sales Order.
    {{else}} {{! This means totalPurchaseOrderCount > 1 }}
      Multiple ({{totalPurchaseOrderCount}}) Purchase Order documents are provided. For this comparison, **focus primarily on the FIRST Purchase Order document listed below** when comparing line items and specific PO values against the Sales Order. You may reference other POs for context if it helps clarify discrepancies or matches related to the first PO, but the detailed values (quantities, prices) reported for 'purchaseOrderValue' or 'poProductDescription' etc., should come from the first PO.
      First Purchase Order Document:
      {{media url=firstPurchaseOrderPdfDataUri}}

      {{#if hasAdditionalPOs}}
        Additional Purchase Order Documents ({{additionalPOCount}} for context, less detailed focus):
        {{#each additionalPurchaseOrderUris}}
          Additional PO (Context): {{media url=this}}
        {{/each}}
      {{/if}}
    {{/if}}
  {{else}} {{! This 'else' is for the inner '#if firstPurchaseOrderPdfDataUri' }}
    {{! This case means hasPurchaseOrders was true, but firstPurchaseOrderPdfDataUri was not valid (e.g. empty string from a bad fetch, or other issue) }}
    A Purchase Order document was expected (count: {{totalPurchaseOrderCount}}), but the primary PO document could not be processed or was empty. Please verify the linked Purchase Order documents in the ERP.
    The Sales Order will be analyzed as if no valid Purchase Order was available. For any fields or items that would normally come from a Purchase Order, indicate "N/A - PO Not Processed" or similar. All Sales Order line items should be treated as 'SO_ONLY'. Note the absence of a usable PO in your summary.
  {{/if}}
{{else}}
  No Purchase Order document was provided for comparison. Proceed with analyzing the Sales Order. For any fields or items that would normally come from a Purchase Order, indicate "N/A - No PO Provided" or similar. All Sales Order line items should be treated as 'SO_ONLY'. Your summary should state: "No PO-orders were found".
{{/if}}

Based on your analysis of the document contents, provide the following in a valid JSON format:

**1. General Document Field Comparison (for 'discrepancies' and 'matchedItems' arrays):**
   **A. Discrepancies:** Identify general discrepancies (non-product line items) such as PO Number, Payment Terms, Buyer/Seller addresses, or overall totals/discounts/taxes. For each, populate the 'discrepancies' array with objects specifying: 'field', 'purchaseOrderValue' (from first PO, or "No PO Provided", or "PO Not Processed"), 'salesOrderValue' (from SO), and 'reason'. Also, include any products found in one order but not the other (e.g., field: "Unmatched PO Product: [Product Name/SKU]", salesOrderValue: "Not found in SO", reason: "Product in PO only").
   **B. Matched Items:** Identify general matching items/fields (non-product line items) between the SO and the **first PO (if provided and processed)**. For each, populate the 'matchedItems' array with objects specifying: 'field', 'value', 'matchQuality'.

**2. Detailed Product Line Item Comparison (for 'productLineItemComparisons' array):**
   - Perform a detailed comparison of product line items between the SO and the **first PO (if provided and processed)**. If no PO provided/processed, all SO items are 'SO_ONLY'.
   - For each line item pairing (or an item found only in one document):
     - **Crucially, for all numeric fields (Quantity, UnitPrice, TotalPrice), you must extract the values exactly as they appear in the document, including all visible decimal places. Do not round or normalize these numbers during the initial extraction step. The comparison of these extracted values will be handled by the status logic that follows.** After extraction, for comparison purposes, you may remove common currency symbols (e.g., $, €) and thousands separators (e.g., commas) before attempting numerical comparison.
     - Extract 'poProductDescription', 'poQuantity', 'poUnitPrice', 'poTotalPrice' from the first PO (use "N/A", "No PO Provided", or "PO Not Processed" if SO_ONLY, no PO, or detail missing).
     - Extract 'soProductDescription', 'soQuantity', 'soUnitPrice', 'soTotalPrice' from the SO (use "N/A" if PO_ONLY or detail missing).
     - Determine 'status': 
        'MATCHED' (Product descriptions match or are semantically equivalent AND all corresponding numeric values - Quantity, Unit Price, Total Price - are numerically identical after faithful extraction and basic formatting for comparison), 
        'MISMATCH_QUANTITY', 
        'MISMATCH_UNIT_PRICE', 
        'MISMATCH_TOTAL_PRICE', 
        'MISMATCH_DESCRIPTION', 
        'PO_ONLY', 
        'SO_ONLY', 
        'PARTIAL_MATCH_DETAILS_DIFFER'.
     - Provide 'comparisonNotes' explaining the status.
   - Populate the 'productLineItemComparisons' array.

**3. Summary ('summary' field):**
   Provide a concise 'summary' of the overall comparison. Highlight key discrepancies, confirmed matches, and product line item findings. If no PO was provided, state: "No PO-orders were found". If a PO was expected but couldn't be processed, note this. If any limitations were encountered processing the entirety of any document, explicitly state this.

**Important Output Structure:**
- The 'discrepancies', 'matchedItems', and 'productLineItemComparisons' arrays should always be present as keys. If none are found, their value should be an empty array (\`[]\`).
- The 'summary' field should always be present.
Ensure all fields in the output schema are populated according to your findings.
`,
  config: {
    safetySettings: [
      {
        category: 'HARM_CATEGORY_HARASSMENT',
        threshold: 'BLOCK_MEDIUM_AND_ABOVE',
      },
      {
        category: 'HARM_CATEGORY_HATE_SPEECH',
        threshold: 'BLOCK_MEDIUM_AND_ABOVE',
      },
      {
        category: 'HARM_CATEGORY_SEXUALLY_EXPLICIT',
        threshold: 'BLOCK_MEDIUM_AND_ABOVE',
      },
      {
        category: 'HARM_CATEGORY_DANGEROUS_CONTENT',
        threshold: 'BLOCK_ONLY_HIGH',
      },
    ],
  }
});

const compareOrderDetailsFlow = ai.defineFlow(
  {
    name: 'compareOrderDetailsFlow',
    inputSchema: CompareOrderDetailsInputSchema, // External input remains the same
    outputSchema: StrictCompareOrderDetailsOutputSchema, // Flow returns the strict schema
  },
  async (input): Promise<CompareOrderDetailsOutput> => {
    try {
      const poUris = input.purchaseOrderPdfDataUris || [];
      const additionalPOs = poUris.slice(1);
      const internalPromptInput: InternalPromptInput = {
        salesOrderPdfDataUri: input.salesOrderPdfDataUri,
        hasPurchaseOrders: poUris.length > 0,
        firstPurchaseOrderPdfDataUri: poUris.length > 0 ? poUris[0] : undefined,
        totalPurchaseOrderCount: poUris.length,
        additionalPurchaseOrderUris: additionalPOs,
        isSinglePO: poUris.length === 1,
        hasAdditionalPOs: additionalPOs.length > 0,
        additionalPOCount: additionalPOs.length,
      };

      // Ensure salesOrderPdfDataUri is not an empty string before calling the AI
      if (!internalPromptInput.salesOrderPdfDataUri || internalPromptInput.salesOrderPdfDataUri.trim() === '') {
        console.error('CompareOrderDetailsFlow: Sales Order PDF data URI is empty or missing.');
        // Return a structured error-like output that matches CompareOrderDetailsOutput
        return {
          discrepancies: [],
          matchedItems: [],
          productLineItemComparisons: [],
          summary: 'Comparison failed: The Sales Order document is missing or could not be processed. Please verify the Sales Order in the ERP system.',
        };
      }


      const { output: aiPermissiveOutput } = await compareOrderDetailsPrompt(internalPromptInput);

      if (!aiPermissiveOutput) {
        console.error('CompareOrderDetailsFlow: AI model returned null or undefined output payload.');
        // Consider if a more structured error should be returned to the client here
        // For now, providing a default summary and empty arrays as per schema.
        return {
            discrepancies: [],
            matchedItems: [],
            productLineItemComparisons: [],
            summary: 'AI model failed to return valid comparison data. Please check the documents or try again. Ensure the Sales Order document is readable.',
        };
      }
      
      const finalOutput: CompareOrderDetailsOutput = {
        discrepancies: Array.isArray(aiPermissiveOutput.discrepancies) ? aiPermissiveOutput.discrepancies : [],
        matchedItems: Array.isArray(aiPermissiveOutput.matchedItems) ? aiPermissiveOutput.matchedItems : [],
        productLineItemComparisons: Array.isArray(aiPermissiveOutput.productLineItemComparisons) ? aiPermissiveOutput.productLineItemComparisons : [],
        summary: typeof aiPermissiveOutput.summary === 'string' && aiPermissiveOutput.summary.trim() !== '' ? aiPermissiveOutput.summary : 'AI did not provide a summary for this comparison.',
      };
      
      return finalOutput;
    } catch (error: unknown) { 
      console.error("Error in compareOrderDetailsFlow: ", error);
      // Default structured output in case of any unexpected error during the flow
      let errorMessage = 'An unexpected error occurred during the AI comparison process. Please try again.';
      if (error instanceof Error) {
        if (error.message.includes("is not found for API version") || error.message.includes("API key not valid") || error.message.includes("Permission denied")) {
            errorMessage = `AI Model/API Key Error: ${error.message}. Please check model availability and API key permissions.`;
        } else if (error.message.includes("Invalid input") || error.message.includes("Request payload size exceeds the limit")) { 
            errorMessage = `There was an issue with the data provided to the AI: ${error.message}. This could be due to very large documents or an internal processing error.`;
        } else if (error.message.includes("upstream connect error") || error.message.includes("Deadline exceeded")) {
            errorMessage = `The AI service is currently unavailable or timed out. Please try again later. Error: ${error.message}`;
        }
         else {
            errorMessage = `An error occurred in the AI flow: ${error.message}`;
        }
      } else {
        errorMessage = `An unknown error occurred in the AI flow: ${String(error)}`;
      }

      return {
        discrepancies: [],
        matchedItems: [],
        productLineItemComparisons: [],
        summary: errorMessage,
      };
    }
  }
);

