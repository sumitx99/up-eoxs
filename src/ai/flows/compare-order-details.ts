
// This is an autogenerated file from Firebase Studio.

'use server';

/**
 * @fileOverview Compares product names, quantities, discounts, and taxes between a sales order document and one or more purchase order documents (PDF, image, CSV, or Excel) using AI.
 * If multiple Purchase Orders are provided, the AI is currently instructed to focus on the first one for detailed comparison against the Sales Order.
 * Identifies both discrepancies and matching items for overall fields, and provides a detailed comparison for product line items.
 *
 * - compareOrderDetails - Compares order details from document content and identifies discrepancies, matches, and detailed product line comparisons.
 * - CompareOrderDetailsInput - The input type for the compareOrderDetails function, expecting documents as data URIs.
 * - CompareOrderDetailsOutput - The output type for the compareOrderdetails function.
 * - Discrepancy - Type for general discrepancies for Payment Terms.
 * - ProductLineItemComparison - Type for detailed product line item comparisons.
 */

import {ai} from '@/ai/genkit';
import {z} from 'genkit';

const CompareOrderDetailsInputSchema = z.object({
  salesOrderPdfDataUri: z.string().describe("The sales order document (PDF, image, CSV, or Excel) as a data URI. Expected format: 'data:<mimetype>;base64,<encoded_data>'."),
  purchaseOrderPdfDataUris: z.array(z.string()).describe("An array of purchase order documents (PDF, image, CSV, or Excel) as data URIs. Expected format: 'data:<mimetype>;base64,<encoded_data>'. Can be an empty array if no POs are linked or found."),
});
export type CompareOrderDetailsInput = z.infer<typeof CompareOrderDetailsInputSchema>;

// New internal schema for the prompt after data pre-processing
const InternalPromptInputSchema = z.object({
  salesOrderPdfDataUri: z.string(),
  firstPurchaseOrderPdfDataUri: z.string().optional(),
  hasPurchaseOrders: z.boolean(),
  totalPurchaseOrderCount: z.number(),
  additionalPurchaseOrderUris: z.array(z.string()),
  isSinglePO: z.boolean(),
  hasAdditionalPOs: z.boolean(),
  additionalPOCount: z.number(),
});
type InternalPromptInput = z.infer<typeof InternalPromptInputSchema>;


const DiscrepancySchema = z.object({
  field: z.enum(['Payment Terms']).describe('The general document field with a discrepancy.'),
  poValue: z.string().describe('The value from the purchase order document.'),
  soValue: z.string().describe('The value from the sales order document.'),
  status: z.enum(['MISMATCH_FIELD']).describe('The status is always MISMATCH_FIELD for this type.'),
  notes: z.string().describe('A brief explanation of the discrepancy, e.g., "Payment terms differ."'),
});
export type Discrepancy = z.infer<typeof DiscrepancySchema>;

const ProductLineItemComparisonSchema = z.object({
  poProductDescription: z.string().optional().describe('Product name or description from the Purchase Order line item. Should be omitted or null for SO_ONLY items.'),
  poQuantity: z.string().optional().describe('Quantity from the Purchase Order line item. Should be omitted or null for SO_ONLY items.'),
  poUnitPrice: z.string().optional().describe('Unit price from the Purchase Order line item. Should be omitted or null for SO_ONLY items.'),
  poTotalPrice: z.string().optional().describe('Total price for the line item from the Purchase Order. Should be omitted or null for SO_ONLY items.'),
  soProductDescription: z.string().optional().describe('Product name or description from the Sales Order line item. Should be omitted or null for PO_ONLY items.'),
  soQuantity: z.string().optional().describe('Quantity from the Sales Order line item. Should be omitted or null for PO_ONLY items.'),
  soUnitPrice: z.string().optional().describe('Unit price from the Sales Order line item. Should be omitted or null for PO_ONLY items.'),
  soTotalPrice: z.string().optional().describe('Total price for the line item from the Sales Order. Should be omitted or null for PO_ONLY items.'),
  status: z.enum(['MATCHED', 'MISMATCH_QUANTITY', 'MISMATCH_UNIT_PRICE', 'MISMATCH_TOTAL_PRICE', 'PO_ONLY', 'SO_ONLY']).describe('The comparison status for this product line item pairing.'),
  comparisonNotes: z.string().describe('AI\'s brief notes explaining the status or highlighting specific differences for this line item (e.g., "Quantities differ", "Unit prices mismatch", "Product found only in PO").'),
});
export type ProductLineItemComparison = z.infer<typeof ProductLineItemComparisonSchema>;

const StrictCompareOrderDetailsOutputSchema = z.object({
  discrepancies: z.array(DiscrepancySchema).describe('A list of general discrepancies found for Payment Terms.'),
  productLineItemComparisons: z.array(ProductLineItemComparisonSchema).describe('An array detailing the comparison of each product line item found in the documents.'),
});
export type CompareOrderDetailsOutput = z.infer<typeof StrictCompareOrderDetailsOutputSchema>;

const AiPermissiveOutputSchema = z.object({
  discrepancies: z.array(DiscrepancySchema).optional(),
  productLineItemComparisons: z.array(ProductLineItemComparisonSchema).optional(),
});


export async function compareOrderDetails(input: CompareOrderDetailsInput): Promise<CompareOrderDetailsOutput> {
  return compareOrderDetailsFlow(input);
}

const compareOrderDetailsPrompt = ai.definePrompt({
  name: 'compareOrderDetailsPrompt',
  input: {
    schema: InternalPromptInputSchema,
  },
  output: {
    schema: AiPermissiveOutputSchema,
  },
  prompt: `You are an AI assistant specializing in comparing sales orders (SOs) with associated purchase orders (POs). Your goal is to meticulously analyze the provided documents and produce a structured JSON output detailing discrepancies.

First, analyze the provided documents. They can be in PDF, image (e.g., JPEG, PNG), CSV, or Excel format. Extract all text and data, paying attention to headers, line items, and footers from all pages.

Sales Order Document:
{{media url=salesOrderPdfDataUri}}

Purchase Order Document(s):
{{#if hasPurchaseOrders}}
  {{#if firstPurchaseOrderPdfDataUri}}
    For this comparison, focus primarily on the **FIRST Purchase Order document**.
    First Purchase Order Document:
    {{media url=firstPurchaseOrderPdfDataUri}}
  {{/if}}
{{else}}
  No Purchase Order document was provided for comparison.
{{/if}}

After extracting the data, you must produce a JSON object with two lists: 'productLineItemComparisons' and 'discrepancies'.

**1. Product Line Item Comparisons ('productLineItemComparisons' array):**
   Compare the line items from the SO and the first PO. For each comparison, create an object with the specified fields.

   *Matching Rules*:
   - **Descriptions**: Compare descriptions fuzzily. Ignore punctuation, case, ordering of numeric descriptors, and synonyms (e.g., THK vs. THICK). For example, treat 'DISC BLANK, 6.25"OD X 2" THICK' and 'Plate A240 2" Circle 6.25 OD' as a potential match. A true match depends on the other fields aligning.
   - **Status Determination**:
     - 'MATCHED': If description has a fuzzy match AND quantity and prices agree.
     - 'MISMATCH_QUANTITY': If description matches but quantity differs.
     - 'MISMATCH_UNIT_PRICE': If description matches but unit price differs.
     - 'MISMATCH_TOTAL_PRICE': If description, quantity, and unit price match, but total price differs.
     - 'PO_ONLY': A PO line item has no fuzzy match in the SO. The 'so...' fields for this entry should be null or omitted.
     - 'SO_ONLY': An SO line item has no fuzzy match in the PO. The 'po...' fields for this entry should be null or omitted. This also applies if no PO was provided.
   - **Notes**: Provide a brief explanation for the chosen status in 'comparisonNotes'.

**2. General Discrepancies ('discrepancies' array):**
   Compare the 'Payment Terms' from the SO and the first PO. Use fuzzy logic to compare them. If they differ in any way, create a discrepancy object.
   - **Field to Compare**: 'Payment Terms'.
   - **Output**: For a differing field, create one entry with:
     - 'field': The name of the field ('Payment Terms').
     - 'poValue': The text from the PO.
     - 'soValue': The text from the SO.
     - 'status': Always set to "MISMATCH_FIELD".
     - 'notes': A brief explanation, e.g., "Payment terms differ."

Produce a valid JSON object matching the output schema. Ensure all arrays are present, even if empty.
`,
  config: {
    safetySettings: [
      {
        category: 'HARM_CATEGORY_HARASSMENT',
        threshold: 'BLOCK_MEDIUM_AND_ABOVE',
      },
      {
        category: 'HARM_CATEGORY_HATE_SPEECH',
        threshold: 'BLOCK_MEDIUM_AND_ABOVE',
      },
      {
        category: 'HARM_CATEGORY_SEXUALLY_EXPLICIT',
        threshold: 'BLOCK_MEDIUM_AND_ABOVE',
      },
      {
        category: 'HARM_CATEGORY_DANGEROUS_CONTENT',
        threshold: 'BLOCK_ONLY_HIGH',
      },
    ],
  }
});

const isValidDataUri = (uri: string): boolean => {
  // Basic check: starts with 'data:', contains ';base64,', and has some content after base64,
  // This check is for any MIME type.
  return typeof uri === 'string' && uri.startsWith('data:') && uri.includes(';base64,') && uri.split(';base64,')[1]?.length > 0;
};

const compareOrderDetailsFlow = ai.defineFlow(
  {
    name: 'compareOrderDetailsFlow',
    inputSchema: CompareOrderDetailsInputSchema,
    outputSchema: StrictCompareOrderDetailsOutputSchema,
  },
  async (input): Promise<CompareOrderDetailsOutput> => {
    try {
      if (!isValidDataUri(input.salesOrderPdfDataUri)) {
        console.error('CompareOrderDetailsFlow: Invalid Sales Order data URI provided.');
        throw new Error('The Sales Order document is missing or invalid. Please ensure it is correctly processed and provided as a valid data URI.');
      }

      const validPoUris = (input.purchaseOrderPdfDataUris || []).filter(uri => {
        const isValid = isValidDataUri(uri);
        if (!isValid && typeof uri === 'string' && uri.length > 0) { // Log if it's a non-empty string but not a valid data URI
          console.warn(`CompareOrderDetailsFlow: Filtering out invalid or empty Purchase Order data URI: "${uri.substring(0,50)}..."`);
        }
        return isValid;
      });

      const additionalPOs = validPoUris.slice(1);
      const internalPromptInput: InternalPromptInput = {
        salesOrderPdfDataUri: input.salesOrderPdfDataUri,
        hasPurchaseOrders: validPoUris.length > 0,
        firstPurchaseOrderPdfDataUri: validPoUris.length > 0 ? validPoUris[0] : undefined,
        totalPurchaseOrderCount: validPoUris.length,
        additionalPurchaseOrderUris: additionalPOs,
        isSinglePO: validPoUris.length === 1,
        hasAdditionalPOs: additionalPOs.length > 0,
        additionalPOCount: additionalPOs.length,
      };

      const { output: aiPermissiveOutput } = await compareOrderDetailsPrompt(internalPromptInput);

      if (!aiPermissiveOutput) {
        console.error('CompareOrderDetailsFlow: AI model returned null or undefined output payload.');
        throw new Error('AI model failed to return valid comparison data. This might be due to an issue with the AI service or unprocessable document content.');
      }

      const finalOutput: CompareOrderDetailsOutput = {
        discrepancies: Array.isArray(aiPermissiveOutput.discrepancies) ? aiPermissiveOutput.discrepancies : [],
        productLineItemComparisons: Array.isArray(aiPermissiveOutput.productLineItemComparisons) ? aiPermissiveOutput.productLineItemComparisons : [],
      };

      return finalOutput;
    } catch (error: unknown) {
      console.error("Error in compareOrderDetailsFlow: ", error);
      let errorMessage = "An unexpected error occurred in the AI flow.";
      if (error instanceof Error) {
          errorMessage = error.message;
          if (errorMessage.includes("Converting circular structure to JSON")) {
              errorMessage = "An internal error occurred while processing the AI request. The AI service may have encountered an issue with the data structure. Please try again or check the document contents.";
          } else if (errorMessage.toLowerCase().includes("must supply a `contenttype`")) {
               errorMessage = "An error occurred with document processing for the AI: A document was provided without a recognized type. Please ensure all uploaded files are valid and have standard file extensions (e.g., .pdf, .png, .jpg, .csv).";
          } else if (errorMessage.toLowerCase().includes("request payload size exceeds the limit") || errorMessage.toLowerCase().includes("payload is too large")) {
              errorMessage = "One or more documents are too large for the AI to process. Please try with smaller files or fewer documents.";
          } else if (errorMessage.toLowerCase().includes("deadline exceeded") || errorMessage.toLowerCase().includes("timeout")) {
              errorMessage = "The AI service timed out while processing the documents. This may be due to complex documents or a temporary service issue. Please try again later.";
          } else if (errorMessage.includes("is not found for API version") || errorMessage.includes("API key not valid") || errorMessage.includes("Permission denied")) {
            errorMessage = `AI Model/API Key Error: ${errorMessage}. Please check model availability and API key permissions.`;
          }
      } else {
        errorMessage = String(error);
      }
      // Throw a new error with the potentially more user-friendly message
      throw new Error(`An error occurred in the AI flow: ${errorMessage}`);
    }
  }
);
